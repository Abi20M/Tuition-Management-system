import student from "../models/student.model";
// import exam from "../models/Exam.model";
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import "dotenv/config";
import studentMail from "../Mails/student.mail";
import Class from "../models/class.model";

//generate student Id
const generateStudentId = async () => {
  //get last student object, if there is a student, then return that student object, otherwise return empty array
  const lastStudentDetails = await student.find().sort({ _id: -1 }).limit(1);

  //check if the result array is empty or not, if its empty then return first student Id
  if (lastStudentDetails.length == 0) {
    return "STD-001";
  }

  //if array is not null, last student object id
  const studentId = lastStudentDetails.map((data) => {
    return data.id;
  });

  //then we get the Integer value from the last part of the ID
  const oldStudentId = parseInt(studentId[0].split("-")[1]);

  const newStudentId = oldStudentId + 1; //then we add 1 to the past value

  //then we return the id according to below conditions
  if (newStudentId >= 100) {
    return `STD-${newStudentId}`;
  } else if (newStudentId >= 10) {
    return `STD-0${newStudentId}`;
  } else {
    return `STD-00${newStudentId}`;
  }
};

export const createStudent = async (studentObj, purePassword) => {
  const emailExists = await student.findOne({ email: studentObj.email });
  if (emailExists) {
    throw new Error("Email already exists");
  } else {
    //generate Student Id
    const stdId = await generateStudentId();

    //create new Student obj with custom student ID
    const newStudentObj = {
      id: stdId,
      name: studentObj.name,
      email: studentObj.email,
      password: studentObj.password,
      phone: studentObj.phone,
      birthDate: studentObj.birthDate,
      school: studentObj.school,
      grade: studentObj.grade,
      address: studentObj.address,
      gender: studentObj.gender,
      parent: studentObj.parent,
    };

    return await student
      .create(newStudentObj)
      .then(async (data) => {
        await data.save();

        // send autogenerated password to the student
        studentMail.sendGeneratedPassowrd(
          studentObj.name,
          studentObj.email,
          purePassword
        );
        return data;
      })
      .catch((err) => {
        throw new Error(err.message);
      });
  }
};

export const getStudent = async (id) => {
  return await student
    .findById(id)
    .then((data) => {
      if (data) {
        return data;
      } else {
        throw new Error("Student not found");
      }
    })
    .catch((err) => {
      throw new Error(err.message);
    });
};

export const getAllStudents = async () => {
  return await student
    .find()
    .then((data) => {
      return data;
    })
    .catch((err) => {
      throw new Error(err.message);
    });
};

export const updateStudent = async (id, studentObj) => {
  return await student
    .findByIdAndUpdate(id, studentObj, { new: true })
    .then((data) => {
      if (data) {
        return data;
      } else {
        throw new Error("Student not found");
      }
    })
    .catch((err) => {
      throw new Error(err.message);
    });
};

export const deleteStudent = async (id) => {
  return await student
    .findByIdAndDelete(id)
    .then((data) => {
      if (data) {
        return data;
      } else {
        throw new Error("Student not found");
      }
    })
    .catch((err) => {
      throw new Error(err.message);
    });
};

export const getStudentCountService = async () => {
  return await student.countDocuments();
};
export const loginStudent = async (email, password) => {
  return await student
    .findOne({ email })
    .then((data) => {
      if (data) {
        if (bcrypt.compareSync(password, data.password)) {
          const accessToken = jwt.sign(
            {
              _id: data._id,
              email: data.email,
              role: "student",
            },
            process.env.ACCESS_TOKEN_SECRET,
            {
              expiresIn: "1d",
            }
          );

          // check if user already changed password or not
          if (data.isPasswordChanged === false) {
            //create response object
            const responseObj = {
              _id: data._id,
              name: data.name,
              id: data.id,
              email: data.email,
              isChangedPassoword: data.isPasswordChanged,
              accessToken: accessToken,
            };
            return responseObj;
          } else {
            //create response object
            const responseObj = {
              _id: data._id,
              name: data.name,
              id: data.id,
              email: data.email,
              isChangedPassoword: data.isPasswordChanged,
              accessToken: accessToken,
            };
            return responseObj;
          }
        } else {
          throw new Error("Invalid Login Credentials");
        }
      } else {
        throw new Error("Invalid Login Credentials");
      }
    })
    .catch((err) => {
      throw new Error(err.message);
    });
};

export const changeStudentPassword = async (studentId, password) => {
  return await student.findById(studentId).then(async (data) => {
    if (bcrypt.compareSync(password.currentPassword, data.password)) {
      return student
        .findByIdAndUpdate(
          studentId,
          { password: password.newPassword, isPasswordChanged: true },
          { new: true }
        )
        .then((updateStudent) => {
          const accessToken = jwt.sign(
            {
              _id: updateStudent._id,
              email: updateStudent.email,
              role: "student",
            },
            process.env.ACCESS_TOKEN_SECRET,
            {
              expiresIn: "1d",
            }
          );

          // check if user already changed password or not
          if (data.isPasswordChanged === false) {
            //create response object
            const responseObj = {
              _id: updateStudent._id,
              name: updateStudent.name,
              id: updateStudent.id,
              email: updateStudent.email,
              isChangedPassoword: updateStudent.isPasswordChanged,
              accessToken: accessToken,
            };
            return responseObj;
          } else {
            //create response object
            const responseObj = {
              _id: data._id,
              name: data.name,
              id: data.id,
              email: data.email,
              isChangedPassoword: data.isPasswordChanged,
              accessToken: accessToken,
            };
            return responseObj;
          }
        })
        .catch((error) => {
          throw new Error("Error while updating document");
        });
    } else {
      throw new Error("Current password is wrong");
    }
  });
};

export const verifyStudent = async (token) => {
  return jwt.verify(token, process.env.TOKEN_SECRET, (err, decoded) => {
    if (err) {
      throw new Error("Invalid token");
    } else {
      return decoded;
    }
  });
};

export const getClassesByStudentId = async (id) => {
  return await Class.find({ students: { _id: id } })
    .then((data) => {
      return data;
    })
    .catch((error) => {
      throw new Error("Invalid student ID");
    });
};

export const genderDistribution = async () => {
  let studentGender = [{ Male: 0, Female: 0 }];
  await student.find().then((data) => {
    data.map((student) => {
      if (student.gender === "male") {
        studentGender[0].Male += 1;
      } else {
        studentGender[0].Female += 1;
      }
    });
  });

  return studentGender;
};

export const getStudentsGradeService = async () => {
  const studentGradeCount = {
    6: 0,
    7: 0,
    8: 0,
    9: 0,
    10: 0,
    11: 0,
    12: 0,
    13: 0,
  };

  await student.find().then((result) => {
    result.map((student) => {
      if (student.grade === "6") {
        studentGradeCount[6]++;
      } else if (student.grade === "7") {
        studentGradeCount[7]++;
      } else if (student.grade === "8") {
        studentGradeCount[8]++;
      } else if (student.grade === "9") {
        studentGradeCount[9]++;
      } else if (student.grade === "10") {
        studentGradeCount[10]++;
      } else if (student.grade === "11") {
        studentGradeCount[11]++;
      } else if (student.grade === "12") {
        studentGradeCount[12]++;
      } else {
        studentGradeCount[13]++;
      }
    });
  });

  return studentGradeCount;
};
export const updateFee = async (id, studentObj) => {
  return await student
    .findByIdAndUpdate(id, studentObj, { new: true })
    .then((data) => {
      if (data) {
        return data;
      } else {
        throw new Error("Student not found");
      }
    })
    .catch((err) => {
      throw new Error(err.message);
    });
};

export const getExamsByStudentId = async (id) => {
  let allExams = await exam.find();
  //check if student id is in marks array
  let studentExams = allExams.filter((exam) => {
    return exam.marks.some((mark) => {
      return mark.id == id;
    });
  });
  return studentExams;
};

module.exports = {
  createStudent,
  getStudent,
  getAllStudents,
  updateStudent,
  deleteStudent,
  getStudentCountService,
  loginStudent,
  changeStudentPassword,
  getClassesByStudentId,
  updateFee,
  genderDistribution,
  getStudentsGradeService,
  updateFee,
  //   verifyStudent,
  getExamsByStudentId,
};
