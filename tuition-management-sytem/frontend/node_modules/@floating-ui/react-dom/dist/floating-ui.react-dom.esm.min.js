import{arrow as e,computePosition as t}from"@floating-ui/dom";export{autoPlacement,autoUpdate,computePosition,detectOverflow,flip,getOverflowAncestors,hide,inline,limitShift,offset,platform,shift,size}from"@floating-ui/dom";import*as r from"react";import{useLayoutEffect as n,useEffect as o}from"react";import*as u from"react-dom";const i=t=>{const{element:r,padding:n}=t;return{name:"arrow",options:t,fn(t){return o=r,Object.prototype.hasOwnProperty.call(o,"current")?null!=r.current?e({element:r.current,padding:n}).fn(t):{}:r?e({element:r,padding:n}).fn(t):{};var o}}};var c="undefined"!=typeof document?n:o;function s(e,t){if(e===t)return!0;if(typeof e!=typeof t)return!1;if("function"==typeof e&&e.toString()===t.toString())return!0;let r,n,o;if(e&&t&&"object"==typeof e){if(Array.isArray(e)){if(r=e.length,r!=t.length)return!1;for(n=r;0!=n--;)if(!s(e[n],t[n]))return!1;return!0}if(o=Object.keys(e),r=o.length,r!==Object.keys(t).length)return!1;for(n=r;0!=n--;)if(!Object.prototype.hasOwnProperty.call(t,o[n]))return!1;for(n=r;0!=n--;){const r=o[n];if(("_owner"!==r||!e.$$typeof)&&!s(e[r],t[r]))return!1}return!0}return e!=e&&t!=t}function f(e){void 0===e&&(e={});const{placement:n="bottom",strategy:o="absolute",middleware:i=[],whileElementsMounted:f,open:l}=e,[a,m]=r.useState({x:null,y:null,strategy:o,placement:n,middlewareData:{},isPositioned:!1}),[p,d]=r.useState(i);s(p,i)||d(i);const g=r.useRef(null),y=r.useRef(null),h=r.useRef(a),w=function(e){const t=r.useRef(e);return c((()=>{t.current=e})),t}(f),[b,P]=r.useState(null),[O,S]=r.useState(null),R=r.useCallback((e=>{g.current!==e&&(g.current=e,P(e))}),[]),j=r.useCallback((e=>{y.current!==e&&(y.current=e,S(e))}),[]),k=r.useCallback((()=>{g.current&&y.current&&t(g.current,y.current,{middleware:p,placement:n,strategy:o}).then((e=>{const t={...e,isPositioned:!0};v.current&&!s(h.current,t)&&(h.current=t,u.flushSync((()=>{m(t)})))}))}),[p,n,o]);c((()=>{!1===l&&h.current.isPositioned&&(h.current.isPositioned=!1,m((e=>({...e,isPositioned:!1}))))}),[l]);const v=r.useRef(!1);c((()=>(v.current=!0,()=>{v.current=!1})),[]),c((()=>{if(b&&O){if(w.current)return w.current(b,O,k);k()}}),[b,O,k,w]);const M=r.useMemo((()=>({reference:g,floating:y,setReference:R,setFloating:j})),[R,j]),x=r.useMemo((()=>({reference:b,floating:O})),[b,O]);return r.useMemo((()=>({...a,update:k,refs:M,elements:x,reference:R,floating:j})),[a,k,M,x,R,j])}export{i as arrow,f as useFloating};
